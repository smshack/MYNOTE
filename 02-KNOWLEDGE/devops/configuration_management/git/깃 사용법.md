---
tags:
  - git
  - 형상관리
---

### 1. Git 기초 개념 및 사용법

**1.1 Git이란?**

> Git은 분산 버전 관리 시스템(Distributed Version Control System)입니다. 파일의 변경 이력을 추적하고, 협업을 용이하게 하며, 이전 버전으로 되돌리는 기능을 제공합니다.

**1.2 Git 기본 용어**

* **Repository (저장소):** 프로젝트의 모든 파일과 변경 이력을 저장하는 공간. 로컬 저장소와 원격 저장소가 있습니다.
* **Commit (커밋):** 파일의 변경 사항을 저장하는 단위. 각 커밋은 변경 내용, 작성자, 날짜 등의 정보를 포함합니다.
* **Branch (브랜치):** 독립적인 개발 라인. 기능을 개발하거나 버그를 수정할 때, 메인 브랜치에서 분기하여 작업할 수 있습니다.
* **Merge (병합):** 브랜치의 변경 사항을 다른 브랜치에 적용하는 작업.
* **Clone (클론):** 원격 저장소의 내용을 로컬 저장소로 복사하는 작업.
* **Pull (풀):** 원격 저장소의 변경 사항을 로컬 저장소로 가져오는 작업.
* **Push (푸시):** 로컬 저장소의 변경 사항을 원격 저장소로 업로드하는 작업.

**1.3 Git 기본 명령어**

| 명령어 | 설명 |
|---|---|
| `git init` | 새로운 Git 저장소를 생성 |
| `git clone [url]` | 원격 저장소를 복제 |
| `git add [file]` | 변경된 파일을 스테이징 영역에 추가 |
| `git commit -m "메시지"` | 스테이징 영역의 변경 사항을 커밋 |
| `git branch [브랜치명]` | 새로운 브랜치 생성 |
| `git checkout [브랜치명]` | 브랜치 전환 |
| `git merge [브랜치명]` | 현재 브랜치에 다른 브랜치 병합 |
| `git pull` | 원격 저장소의 변경 사항을 가져와 현재 브랜치에 병합 |
| `git push` | 로컬 저장소의 변경 사항을 원격 저장소에 업로드 |
| `git status` | 현재 저장소 상태 확인 |
| `git log` | 커밋 이력 확인 |
| `git diff` | 변경 사항 확인 |

**1.4 Git 사용 흐름**

1.  `git clone` 또는 `git init`으로 저장소를 생성합니다.
2.  `git add`로 변경된 파일을 스테이징 영역에 추가합니다.
3.  `git commit`으로 스테이징 영역의 변경 사항을 커밋합니다.
4.  원격 저장소에 `git push`하여 변경 사항을 업로드합니다.
5.  다른 개발자의 변경 사항을 `git pull`하여 로컬 저장소에 반영합니다.


## 2.실무 Git 사용 시나리오 & 해결 명령어

> 실무에서 Git을 사용하다 보면 다양한 상황에 직면할 수 있습니다. 몇 가지 대표적인 시나리오와 해결 명령어를 정리해 드리겠습니다.

### 2.1. 기능 개발 및 병합

*   **시나리오:** 새로운 기능을 개발해야 합니다. 메인 브랜치(보통 `main` 또는 `master`)에서 브랜치를 분기하여 개발하고, 개발이 완료되면 다시 병합합니다.
*   **해결:**
    1.  **브랜치 생성:** `git checkout -b feature/new-feature` (새로운 브랜치 생성 및 전환)
    2.  **개발:** 기능 개발 및 커밋
    3.  **원격 브랜치 푸시:** `git push origin feature/new-feature` (원격 저장소에 브랜치 푸시)
    4.  **Pull Request (PR) 생성:** GitHub, GitLab 등에서 PR 생성 및 코드 리뷰
    5.  **PR 승인 및 병합:** PR 승인 후, 메인 브랜치로 병합
    6.  **로컬 브랜치 동기화:** `git checkout main` (메인 브랜치로 이동) -> `git pull` (최신 변경 사항 가져오기) -> `git branch -d feature/new-feature` (로컬 브랜치 삭제)

### 2.2. 충돌 해결 (Conflict Resolution)

*   **시나리오:** 여러 개발자가 동시에 동일한 파일을 수정하여 병합 시 충돌이 발생했습니다.
*   **해결:**
    1.  **충돌 파일 확인:** `git status` 명령어를 통해 충돌 파일 확인
    2.  **충돌 부분 수정:** 충돌 파일 열어 `<<<<<<<`, `=======`, `>>>>>>>` 표시된 부분을 수정하여 원하는 코드로 병합
    3.  **수정된 파일 추가 및 커밋:** `git add <충돌 파일>` -> `git commit -m "충돌 해결"`

### 2.3. 실수로 커밋된 내용 되돌리기

*   **시나리오:** 실수로 잘못된 내용을 커밋했습니다.
*   **해결:**
    1.  **마지막 커밋 취소:** `git revert HEAD` (마지막 커밋을 취소하는 새로운 커밋 생성. 히스토리가 유지됨) 또는 `git reset --soft HEAD^` (마지막 커밋을 취소하고 스테이징 영역에 변경 사항 유지)
    2.  **스테이징 영역에서 변경 사항 제거:** `git reset HEAD <파일명>` (특정 파일의 변경 사항 제거)
    3.  **커밋 취소 후 변경 사항 수정:** 필요에 따라 변경 사항 수정 후 다시 커밋

### 2.4. 이전 커밋으로 되돌리기 (Reset)

*   **시나리오:** 특정 시점의 코드로 되돌리고 싶습니다.
*   **해결:**
    1.  **특정 커밋 해시 찾기:** `git log` 명령어를 사용하여 원하는 커밋 해시 확인
    2.  **해당 커밋으로 Reset:** `git reset --hard <커밋 해시>` (주의: 이 명령어는 작업 디렉토리의 모든 변경 사항을 삭제합니다. 백업 필수!)

### 2.5. 원격 저장소 변경 사항 가져오기 (Fetch & Pull)

*   **시나리오:** 원격 저장소에 있는 다른 개발자의 변경 사항을 가져와야 합니다.
*   **해결:**
    1.  **원격 저장소 정보 확인:** `git remote -v`
    2.  **원격 저장소 변경 사항 Fetch:** `git fetch origin` (원격 저장소의 변경 사항을 가져오지만, 로컬 브랜치에 병합하지는 않습니다.)
    3.  **원격 저장소 변경 사항 Pull:** `git pull origin main` (원격 저장소의 변경 사항을 가져와 현재 브랜치에 병합합니다.)

### 2.6. 브랜치 삭제 (Delete Branch)

*   **시나리오:** 더 이상 필요 없는 브랜치를 삭제해야 합니다.
*   **해결:**
    1.  **로컬 브랜치 삭제:** `git branch -d <브랜치명>` (병합된 브랜치 삭제) 또는 `git branch -D <브랜치명>` (병합되지 않은 브랜치 강제 삭제)
    2.  **원격 브랜치 삭제:** `git push origin --delete <브랜치명>`

**2.7. 커밋 메시지 수정**

*   **시나리오:** 커밋 메시지를 잘못 작성하여 수정해야 합니다.
*   **해결:**
    1.  `git commit --amend -m "수정된 커밋 메시지"` (가장 최근 커밋 메시지 수정)

```ad-tip
*   **`.gitignore` 파일 활용:** 불필요한 파일(빌드 결과, 로그 파일 등)이 Git에 포함되지 않도록 `.gitignore` 파일을 작성합니다.
*   **Git Alias 설정:** 자주 사용하는 Git 명령어를 짧은 Alias로 설정하여 사용 편의성을 높입니다. (`git config --global alias.co checkout`)
*   **브랜치 전략:** Gitflow, GitHub Flow 등 적절한 브랜치 전략을 선택하여 프로젝트를 관리합니다.
*   **Git GUI 도구 활용:** SourceTree, GitKraken 등 Git GUI 도구를 사용하면 시각적으로 Git을 관리할 수 있습니다.
```



이 외에도 다양한 상황이 발생할 수 있습니다. Git 공식 문서 및 온라인 자료를 참고하여 문제 해결에 도움을 받으시기 바랍니다.

## 3. Git Stash 사용 시나리오 및 명령어 정리

```ad-info
Git Stash는 현재 작업 중인 변경 사항을 임시로 저장해두고, 워킹 디렉토리를 깨끗하게 만들어주는 기능입니다. 급하게 다른 브랜치로 이동하거나, 풀 리퀘스트를 처리해야 할 때 유용하게 사용됩니다.
```

### 3.1. Git Stash 사용 시나리오

**시나리오 1: 급한 버그 수정**

개발자 A는 새로운 기능을 개발하던 중, 갑자기 중요한 버그 수정 요청을 받았습니다. 하지만 A는 현재 작업 중인 기능의 변경 사항을 커밋하기에는 아직 이르다고 생각합니다. A는 Git Stash를 사용하여 현재 작업 중인 변경 사항을 임시로 저장해두고, 버그 수정 브랜치로 이동하여 버그를 수정합니다. 버그 수정이 완료된 후, A는 Stash에 저장해둔 변경 사항을 다시 적용하여 기능 개발을 이어갑니다.

**시나리오 2: Pull Request 처리**

개발자 B는 Pull Request를 검토하던 중, 몇 가지 수정 사항을 발견했습니다. 하지만 B는 현재 작업 중인 기능의 변경 사항을 커밋하지 않았고, 다른 사람의 Pull Request를 처리하기 위해 워킹 디렉토리를 깨끗하게 만들어야 합니다. B는 Git Stash를 사용하여 현재 작업 중인 변경 사항을 임시로 저장해두고, 다른 사람의 Pull Request를 처리합니다. Pull Request 처리가 완료된 후, B는 Stash에 저장해둔 변경 사항을 다시 적용하여 기능 개발을 이어갑니다.

### 3.2. Git Stash 명령어 정리

*   **`git stash`**: 현재 변경 사항을 Stash에 저장합니다. (기본적으로 메시지 없이 저장)
*   **`git stash save "메시지"`**:  현재 변경 사항을 Stash에 저장하고, 메시지를 함께 저장합니다. (메시지를 통해 저장된 변경 사항을 쉽게 식별할 수 있습니다.)
*   **`git stash list`**:  Stash에 저장된 목록을 확인합니다. (Stash ID, 메시지 등을 확인할 수 있습니다.)
*   **`git stash apply`**:  가장 최근에 Stash에 저장된 변경 사항을 적용합니다. (Stash 목록에서 특정 Stash ID를 지정하여 적용할 수도 있습니다.)
*   **`git stash pop`**:  가장 최근에 Stash에 저장된 변경 사항을 적용하고, Stash 목록에서 제거합니다.
*   **`git stash drop`**:  특정 Stash ID 또는 가장 최근 Stash를 제거합니다.
*   **`git stash clear`**:  모든 Stash를 제거합니다.
*   **`git stash branch <브랜치 이름>`**:  현재 Stash에 저장된 변경 사항을 기반으로 새로운 브랜치를 생성합니다. (새로운 브랜치에서 변경 사항을 적용하고 작업할 수 있습니다.)

### 3.3. Git Stash 사용 예시

1.  **현재 변경 사항 저장:**

    ```bash
    git stash save "feat: 로그인 기능 UI 수정"
    ```

2.  **Stash 목록 확인:**

    ```bash
    git stash list
    ```

    (출력 예시)

    ```
    stash@{0}: On main: feat: 로그인 기능 UI 수정
    ```

3.  **Stash 적용:**

    ```bash
    git stash apply stash@{0}
    ```

    또는

    ```bash
    git stash pop
    ```

4.  **Stash 삭제:**

    ```bash
    git stash drop stash@{0}
    ```

### 3.4. Git Stash 사용 시 주의 사항

*   **충돌 해결:** Stash를 적용할 때 충돌이 발생할 수 있습니다. 충돌을 해결하고 변경 사항을 커밋해야 합니다.
*   **메시지 관리:** Stash 메시지를 통해 저장된 변경 사항을 쉽게 식별할 수 있으므로, 의미 있는 메시지를 사용하는 것이 좋습니다.
*   **장기 보관 지양:** Stash는 임시 저장소이므로, 장기간 보관하는 것은 좋지 않습니다. 필요하다면 브랜치를 생성하여 변경 사항을 관리하는 것이 좋습니다.

### 3.5. Git Stash의 장점

*   **작업 중단 및 재개:** 작업 중단을 빠르게 처리하고 재개할 수 있습니다.
*   **워킹 디렉토리 정리:** 워킹 디렉토리를 깨끗하게 유지하여 다른 작업을 수행할 수 있습니다.
*   **유연한 작업 흐름:** 다양한 상황에서 유연하게 작업 흐름을 관리할 수 있습니다.

## 4. Git Squash 사용 시나리오 

```ad-info
Git Squash는 여러 개의 커밋을 하나의 커밋으로 합치는 기능입니다. 주로 기능 개발 브랜치에서 여러 작은 커밋을 하나의 의미 있는 커밋으로 만들어 메인 브랜치에 병합할 때 사용됩니다.
```
### 4.1. Squash를 사용하는 상황 시나리오

**시나리오:** 개발자 A는 새로운 로그인 기능 개발을 위해 `feature/login` 브랜치를 생성했습니다.

*   A는 기능 구현 과정에서 다음과 같은 커밋을 생성했습니다.
    *   "feat: 로그인 폼 UI 추가"
    *   "fix: 로그인 폼 validation 오류 수정"
    *   "feat: 백엔드 API 연동"
    *   "fix: API 응답 오류 처리"
    *   "feat: 로그인 성공 시 메인 페이지 리다이렉트"

*   A는 기능 개발이 완료되었고, 이제 메인 브랜치에 병합하려고 합니다. 하지만 A는 커밋 히스토리를 깔끔하게 유지하고 싶어합니다.

*   A는 Git Squash를 사용하여 위의 커밋들을 하나의 "feat: 로그인 기능 구현" 커밋으로 합쳐서 메인 브랜치에 병합하기로 결정합니다.

### 4.2. Squash 명령어 정리

**단계 1: Pull Request 생성 및 Squash 옵션 선택**

1.  **Pull Request 생성:** GitHub, GitLab, Bitbucket 등의 플랫폼에서 `feature/login` 브랜치에 대한 Pull Request를 생성합니다.
2.  **Squash 옵션 선택:** Pull Request 생성 시 또는 설정에서 "Squash and merge" 옵션을 선택합니다. (플랫폼마다 용어 및 UI가 다를 수 있습니다.)

**단계 2: 커밋 메시지 작성**

1.  **커밋 메시지 작성:** "Squash and merge" 옵션을 선택하면, Pull Request 페이지에서 합쳐질 커밋들의 목록과 함께 새로운 커밋 메시지를 작성할 수 있는 텍스트 상자가 나타납니다.
2.  **의미 있는 메시지 작성:**  합쳐진 커밋들을 잘 설명하는 간결하고 명확한 메시지를 작성합니다. (예: "feat: 로그인 기능 구현")

**단계 3: Pull Request 병합**

1.  **병합 확인:** 작성한 커밋 메시지를 확인하고, Pull Request를 병합합니다.
2.  **히스토리 확인:** 병합이 완료되면, 메인 브랜치의 히스토리를 확인하여 하나의 커밋으로 합쳐졌는지 확인합니다.

**명령어 (CLI 사용 시)**

만약 GUI가 아닌 CLI를 사용하여 Squash를 수행하려면 다음과 같은 단계를 따릅니다.

1.  **메인 브랜치로 이동:**

    ```bash
    git checkout main
    ```

2.  **feature 브랜치 병합 (Squash 옵션 사용):**

    ```bash
    git merge --squash feature/login
    ```

3.  **커밋 메시지 작성:**

    ```bash
    git commit -m "feat: 로그인 기능 구현"
    ```

4.  **feature 브랜치 삭제 (선택 사항):**

    ```bash
    git branch -d feature/login
    ```

### 4.3. Squash 사용 시 주의 사항

*   **커밋 히스토리 손실:** Squash는 여러 커밋을 하나로 합치기 때문에, 개별 커밋 히스토리를 유지할 수 없습니다. 따라서, 히스토리가 중요한 경우에는 Squash를 사용하지 않는 것이 좋습니다.
*   **코드 리뷰:** Squash를 사용하기 전에 코드 리뷰를 완료하는 것이 좋습니다. 코드 리뷰를 통해 버그나 문제점을 미리 발견하고 수정할 수 있습니다.
*   **팀과의 합의:** Squash를 사용할지 여부는 팀원들과 합의하여 결정하는 것이 좋습니다.

### 4.4. Squash의 장점

*   **깔끔한 히스토리:** 히스토리를 깔끔하게 유지하여 코드 이해를 돕습니다.
*   **간결한 커밋:** 하나의 커밋으로 기능 전체를 표현하여 코드 변경 사항을 쉽게 파악할 수 있습니다.
*   **병합 용이성:** 히스토리가 간결하여 병합 충돌 가능성을 줄입니다.

이 템플릿을 통해 Git Squash를 효과적으로 활용하여 프로젝트 관리를 개선할 수 있습니다.